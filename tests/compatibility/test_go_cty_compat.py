"""
Performs cross-language compatibility tests by deserializing canonical
fixtures generated by the reference `go-cty` implementation and vice-versa.
"""
import subprocess
import sys
from decimal import Decimal
from pathlib import Path

import pytest

from pyvider.cty import (
    CtyBool, CtyDynamic, CtyList, CtyMap, CtyNumber, CtyObject, CtySet,
    CtyString, CtyTuple, CtyValue, convert, unify
)
from pyvider.cty.codec import cty_from_msgpack
from pyvider.cty.exceptions import CtyConversionError
from pyvider.cty.values.markers import RefinedUnknownValue

fset = frozenset

# --- Go -> Python Verification ---

EXPECTED_RESULTS = {
    "string_simple": {"type": CtyString(), "value": "hello world"},
    "number_simple": {"type": CtyNumber(), "value": Decimal("42")},
    "bool_true": {"type": CtyBool(), "value": True},
    "large_number": {"type": CtyNumber(), "value": Decimal(2**100)},
    "null_string": {"type": CtyString(), "is_null": True},
    "unknown_unrefined": {"type": CtyString(), "is_unknown": True},
    "unknown_refined_str": { "type": CtyString(), "is_unknown": True, "value": RefinedUnknownValue(string_prefix="start-") },
    "unknown_refined_num": { "type": CtyNumber(), "is_unknown": True, "value": RefinedUnknownValue(number_lower_bound=(Decimal("100"), True), number_upper_bound=(Decimal("200"), False)) },
    "unknown_refined_list": { "type": CtyList(element_type=CtyString()), "is_unknown": True, "value": RefinedUnknownValue(collection_length_lower_bound=3, collection_length_upper_bound=3) },
    "list_of_strings": { "type": CtyList(element_type=CtyString()), "value": (CtyString().validate("a"), CtyString().validate("b")) },
    "set_of_numbers": { "type": CtySet(element_type=CtyNumber()), "value": frozenset([CtyNumber().validate(1), CtyNumber().validate(2)]) },
    "map_simple": { "type": CtyMap(element_type=CtyBool()), "value": {"a": CtyBool().validate(True), "b": CtyBool().validate(False)} },
    "deeply_nested_object": {
        "type": CtyObject({"id": CtyString(), "enabled": CtyBool(), "ports": CtyList(element_type=CtyNumber()), "config": CtyObject({"retries": CtyNumber(), "params": CtyMap(element_type=CtyString())}), "metadata": CtyMap(element_type=CtyString()), "extra": CtyString()}, optional_attributes={"metadata"}),
        "value": { "id": CtyString().validate("obj1"), "enabled": CtyBool().validate(True), "ports": CtyList(element_type=CtyNumber()).validate([80, 443]), "config": CtyObject({"retries": CtyNumber(), "params": CtyMap(element_type=CtyString())}).validate({"retries": 3, "params": {"timeout": "5s"}}), "metadata": CtyValue.null(CtyMap(element_type=CtyString())), "extra": CtyValue.unknown(CtyString()) },
        "is_unknown": True,
    },
    "dynamic_wrapped_string": {"type": CtyDynamic(), "value": CtyString().validate("dynamic")},
    "dynamic_wrapped_object": { "type": CtyDynamic(), "value": CtyObject({"key": CtyString()}).validate({"key": "value"}) },
}

def deep_value_equal(a: CtyValue, b: CtyValue) -> bool:
    if not isinstance(a, CtyValue) or not isinstance(b, CtyValue): return False
    if not a.type.equal(b.type) or a.is_null != b.is_null or a.is_unknown != b.is_unknown: return False
    if a.is_null or a.is_unknown: return True
    val_a, val_b = a.value, b.value
    if isinstance(val_a, dict) and isinstance(val_b, dict): return val_a.keys() == val_b.keys() and all(deep_value_equal(val_a[k], val_b[k]) for k in val_a)
    if isinstance(val_a, tuple) and isinstance(val_b, tuple): return len(val_a) == len(val_b) and all(deep_value_equal(val_a[i], val_b[i]) for i in range(len(val_a)))
    if isinstance(val_a, frozenset) and isinstance(val_b, frozenset): return len(val_a) == len(val_b) and all(any(deep_value_equal(item_a, item_b) for item_b in val_b) for item_a in val_a)
    return val_a == val_b

@pytest.mark.compat
@pytest.mark.parametrize("fixture_name", EXPECTED_RESULTS.keys())
def test_msgpack_deserialization_from_go_cty(fixture_name: str, go_fixtures: Path):
    expected_spec = EXPECTED_RESULTS[fixture_name]
    expected_type = expected_spec["type"]
    fixture_path = go_fixtures / f"{fixture_name}.msgpack"
    packed_bytes = fixture_path.read_bytes()
    deserialized_val = cty_from_msgpack(packed_bytes, expected_type)
    assert deserialized_val.type.equal(expected_type)
    if expected_spec.get("is_unknown", False):
        assert deserialized_val.is_unknown
        if "value" in expected_spec: assert deserialized_val.value == expected_spec["value"]
    elif expected_spec.get("is_null", False):
        assert deserialized_val.is_null
    else:
        assert not deserialized_val.is_unknown and not deserialized_val.is_null
        expected_value = CtyValue(expected_type, expected_spec["value"])
        assert deep_value_equal(deserialized_val, expected_value)

# --- Python -> Go Verification ---

@pytest.mark.compat
def test_msgpack_serialization_from_python_to_go(tmp_path_factory, pytestconfig, log_dir: Path):
    """
    Tests that fixtures generated by the Python implementation can be
    successfully verified by the Go implementation.
    """
    project_root = pytestconfig.rootpath
    python_generator_script = project_root / "compatibility" / "python" / "generator.py"
    go_compat_dir = project_root / "compatibility" / "go"
    
    py_fixture_dir = tmp_path_factory.mktemp("py-fixtures")

    try:
        subprocess.run(
            [sys.executable, str(python_generator_script), "--directory", str(py_fixture_dir)],
            check=True, capture_output=True, text=True
        )
    except subprocess.CalledProcessError as e:
        pytest.fail(f"Python fixture generator failed:\nSTDOUT:\n{e.stdout}\nSTDERR:\n{e.stderr}", pytrace=False)

    reporter = pytestconfig.pluginmanager.getplugin("terminalreporter")
    reporter.write_line("\n\n--- Verifying Python-generated fixtures with Go tool ---", bold=True)
    
    log_file_path = log_dir / "go-verify-debug.log"
    command = [
        "go", "run", ".",
        "verify",
        "--directory", str(py_fixture_dir.resolve()),
        "--log-file", str(log_file_path.resolve()),
        "--log-level", "trace",
    ]

    try:
        result = subprocess.run(
            command,
            cwd=go_compat_dir, check=True, capture_output=True, text=True
        )
        (log_dir / "go-verify-stdout.log").write_text(result.stdout)
        (log_dir / "go-verify-stderr.log").write_text(result.stderr)
        reporter.write_line(f"✅ Go verifier passed. Logs available at: {log_dir}", green=True)
    except subprocess.CalledProcessError as e:
        (log_dir / "go-verify-stdout.log").write_text(e.stdout)
        (log_dir / "go-verify-stderr.log").write_text(e.stderr)
        log_contents = log_file_path.read_text() if log_file_path.exists() else "Log file not found."
        reporter.write_line(f"❌ Go verifier failed. Logs are available in: {log_dir}", red=True)
        pytest.fail(
            f"Go verifier failed to validate Python fixtures:\n"
            f"STDOUT:\n{e.stdout}\n"
            f"STDERR:\n{e.stderr}\n\n"
            f"--- Go Verifier Log ({log_file_path}) ---\n{log_contents}",
            pytrace=False
        )
